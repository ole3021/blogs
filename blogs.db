{"filename":"/Users/ole3021/playground/blogs/blogs.db","collections":[{"name":"blogs","data":[{"_id":"Mongo-Model-Structure","name":"Mongo Model Structure","category":["Database"],"createdAt":"2018-06-03T00:07:52.000Z","updateAt":"2018-06-03T00:07:52.000Z","size":2050,"meta":{"version":0,"created":1528001956801,"revision":0},"content":"<hr>\n<hr>\n<h1 id=\"mongodb-\">MongoDB 数据结构设计原则</h1>\n<h2 id=\"-1-n-\">一对多 (1…n)</h2>\n<h3 id=\"-10-\">一对很少 (&lt; 10)</h3>\n<h4 id=\"-\">内嵌文档</h4>\n<p>One to Few, 使用<code>内嵌文档</code>很合适。</p>\n<p>Pros:</p>\n<ul>\n<li>不需要单独执行一条语句去获取内嵌内容。</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>无法把内嵌文档当作单独实体去访问。</li>\n</ul>\n<h3 id=\"-1000-\">一对许多 (&lt; 1000)</h3>\n<h4 id=\"-\">数组引用</h4>\n<p>One to Many, 使用<code>数组引用</code>。</p>\n<p>Pros:</p>\n<ul>\n<li>每个关联文档都是单独的，可以独立搜索和更新。</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li><p>需要单独的查询去获取零件内容，需要一个应用层级别的<code>join</code></p>\n<blockquote>\n<p>如果有少量的信息可以使用 <code>反模式</code>，冗余信息来减少join操作。</p>\n<p>Cons:</p>\n<ul>\n<li>更新频率越低越好，越高这种方式价值越少。</li>\n<li>操作室非原子的</li>\n</ul>\n</blockquote>\n</li>\n<li><p>为了保证快速查找，需要创建索引。</p>\n</li>\n</ul>\n<h4 id=\"-\">两端引用</h4>\n<p>相互引用，同时在“一”端和“多”端相互引用。</p>\n<p>Pros:</p>\n<ul>\n<li>在两端不需要做关联就可以快速查找。</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>很难保证操作的原子性。</li>\n</ul>\n<h3 id=\"-1000-\">一对非常多 (&gt; 1000)</h3>\n<h4 id=\"-\">“多”端引用</h4>\n<p>One to Squillions, 使用<code>&quot;多&quot;端引用</code>，在“多”端去引用“一”端。</p>\n<p>Pros:</p>\n<ul>\n<li>可以进行大量的引用而不会触发MongoDB的文档存储上限(16M)</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>“一”端关联数据获取需要进行大量过滤查询</li>\n</ul>\n<h2 id=\"loopback-\">Loopback 关系体系</h2>\n<h3 id=\"model-\">Model关系</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">关系</th>\n<th>适用于</th>\n<th>key</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">BelongsTo</td>\n<td>1…n To 1</td>\n<td>Left</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">HasOne</td>\n<td>1 To 1</td>\n<td>Right?</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">HasMany</td>\n<td>1 To N,1 To 1</td>\n<td>Right</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">HasManyThrough</td>\n<td>N To N</td>\n<td>Through</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"left\">HasAndBelongsToMany</td>\n<td>N To N</td>\n<td>Auto</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"-polymorphic\">多态关系 Polymorphic</h3>\n<h3 id=\"-\">嵌套关系</h3>\n<table>\n<thead>\n<tr>\n<th>关系</th>\n<th>适用于</th>\n<th>key</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EmbedsOne</td>\n<td>| left</td>\n<td></td>\n</tr>\n<tr>\n<td>EmbedsMany</td>\n<td>| left</td>\n<td></td>\n</tr>\n<tr>\n<td>EmbedsMany + BelongsTo</td>\n<td>|</td>\n<td></td>\n</tr>\n<tr>\n<td>References</td>\n<td>| left</td>\n<td></td>\n</tr>\n</tbody></table>\n","$loki":1},{"_id":"Scope-Closure","name":"Scope&Closure","category":["Javascript"],"createdAt":"2018-06-03T00:07:52.000Z","updateAt":"2018-06-03T00:07:52.000Z","size":14879,"meta":{"title":"Scope & Closure","meta":"Summary of JavaScript Scope and Closure knowledge based on \"You Don't Know JS\" series books.","category":"JavaScript","tags":["Don't Know JS"],"cover":"/assets/images/post/scope_closure.png","color":"#606060","created":1528001956802,"version":0,"revision":0},"content":"<h1 id=\"scope\">Scope</h1>\n<p>&quot;Scope&quot; has ability to store values and pull values out of variables is what gives a program state.\n&quot;Scope&quot; as the set of rules tahta govern how the Engine can look up a variable by its identifier name and find it.\nThere are two predominant models for sope works</p>\n<ul>\n<li>Lexical Scope: Most common used by vast majority programming language(JS use Lexical Scope).</li>\n<li>Dynamic Scope: Some languages like (Bash, Perl, etc)</li>\n</ul>\n<h2 id=\"working-process\">Working Process</h2>\n<blockquote>\n<p>Engine: start-to-finish compilation and execution.\nCompiler: Parsing and code-generation.\nScoper: Collects and maintains a look-up list of all the declared identifiers(variables) and value definition(function).</p>\n</blockquote>\n<p>Traditional compiled-languages compilation<a href=\"Appendix\">^compile</a></p>\n<ol>\n<li><em>Compiler</em> will perform lexing and break code into &#39;tokens&#39;, and then pust it in <code>AST</code> tree.</li>\n<li><p>During &quot;Code-Generation&quot; &amp; &quot;Execution&quot;</p>\n<ol>\n<li><p>Declareation: <em>Compiler</em> will check <em>Scope</em> first to see if variable is already exist.</p>\n<ul>\n<li>If exist, ignores.</li>\n<li>Ohterwise <em>Compiler</em> will ask <em>Scope</em> to declare a new variable for that scope colletion</li>\n<li><em>Compiler</em> produce code for <em>Engine</em> execute later with handle assignment</li>\n</ul>\n</li>\n<li><p>Assignment: <em>Engine</em> will ask <em>Scope</em> if there have a variable accessible in cureent scoper colleciton.</p>\n<ul>\n<li>If have, use the variable. After find the variable and <em>Engine</em> will assign the value to it.</li>\n<li><em>Engine</em> will lookup <em>elsewhere*</em> (nested Scope)</li>\n<li>If not find <em>Engine</em> will raise and yell an Error!</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><em>Engine</em> Look-up of <em>Scope</em> have two types</p>\n<ul>\n<li>LHS: left-hand side of an assignment<br>   LHS look-up the target of the assignment (find the variable <strong>container</strong> that can asssignment).</li>\n<li>RHS: right-hand side of an assignemtn<br>RHS look-up the source of the assignment</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<pre><code class=\"language-javascript\">function foo(a) {...}   \n\n// 方法可以通过Compiler进行声明和定义，在Engine执行的过程中不需要向赋值方式思考成先进行LHS，这里只有RHS\n</code></pre>\n</blockquote>\n<h3 id=\"nest-scope\">Nest Scope</h3>\n<p>Like block or function is nested inside another block or function, scope are nested inside other scopes.</p>\n<p><em>Engine</em> starts at the currently executing Scope, looks the bariable if not fund keep going up one level, and so on.</p>\n<h3 id=\"errors\">Errors</h3>\n<ul>\n<li><p><code>ReferenceError</code>: will throw when the RHS/LHS(&#39;Strict Mode&#39;) fails to find a variable, anywhere in nested Scopers(Scope resolution-failure related).</p>\n<blockquote>\n<p>In non-<code>Strict Mode</code> the Scope will create on in the Global Scope, and hand it back to Engine.</p>\n</blockquote>\n</li>\n<li><p><code>Type Error</code>: If the value found with RHS, but try to do something with its value that  is impossible(Scoper resulution successfule, but illegal/impossible action attempted).</p>\n</li>\n</ul>\n<h2 id=\"lexical-scope\">Lexical Scope</h2>\n<p>Lexical Scoper is defined at <code>lexing</code><a href=\"Appendix\">^compile</a> time based on where variables and blocks of scoper are authored, and lexer processes the code.</p>\n<blockquote>\n<p>Modifying lexical scope after lexer has passed by is not frowned upon.</p>\n</blockquote>\n<h3 id=\"scope-bubbles\">Scope Bubbles</h3>\n<p>Scope bubbles are defined by where the blocks of scopes are written.\n<img src=\"/assets/images/post/scope.png\" alt=\"Scope\">\nThere are three scopes inherent in the code above. It is helf to think about these scopes as bubbles inside each other.</p>\n<p>Bubble1: Encompasses the global scope, and has just one identifier <code>foo</code>.\nBubble2: Encompasses the scope of <code>foo</code>, it have identifiers <code>a</code>, <code>b</code> and <code>bar</code>.\nBubbles: Encompasses the scope of <code>bar</code>, it has just one identifier <code>c</code>.</p>\n<ul>\n<li>Each function creates a new bubble of scope.</li>\n<li>Scope look-up stops once it find the first match.</li>\n</ul>\n<blockquote>\n<p>The same identifier name can be specified at multiple layers of nested scoper, which is called &quot;shadowing&quot;(the inner identifier &quot;shadows&quot; the outer identifier)</p>\n</blockquote>\n<h3 id=\"cheating-lexical\">Cheating Lexical</h3>\n<p>JavaScript have two mechanismsm could &quot;modify&quot; lexical scope at run-time. but both are bad practices to use(cheating lexical scope leads to poorer perfoemance).</p>\n<h4 id=\"eval\">eval</h4>\n<p><code>eval(...)</code> takes a string as an argement and treates the contents of the string had been actually authored code at the point in the program.</p>\n<blockquote>\n<ul>\n<li><code>eval()</code> can modify the lexical scope environment during runtime.</li>\n<li>in &quot;strict mode&quot; the <code>eval()</code> operates in its own lexical scope, have no effect on enclosing scope.</li>\n<li>bestide <code>eval</code> there also have <code>setTimeout(&#39;&#39;&#39;)</code>, <code>setInterval(...)</code> and <code>new Function(...)</code>, but dont consider to use them.</li>\n</ul>\n</blockquote>\n<h4 id=\"with\">with</h4>\n<p><code>with</code> is explained as a short-hand for making multiple property references aginst as object <em>without</em> repeating the object reference itsef each time.</p>\n<p><code>with</code> statement taks an object, one which has zero or more properties, and <strong>treates that object as if it is a wholly spearate lexical scope</strong>.</p>\n<blockquote>\n<p>this could some time(non-strict mode) cause leaked global issue(object have no property that <code>with</code> to assignment).</p>\n</blockquote>\n<h2 id=\"function-vs-block-scope\">Function vs. Block Scope</h2>\n<h3 id=\"scope-from-functions\">Scope from Functions</h3>\n<p>The most common scope is function-based scope. Each function declared create a bubble for itself.\nwith the function scope there have the benefits like</p>\n<ul>\n<li>Hiding in plain scope</li>\n<li>Collision Avoidance</li>\n</ul>\n<h3 id=\"functions-as-scopes\">Functions as Scopes</h3>\n<p>Use scopes from functions there are few problems.</p>\n<ul>\n<li>Have to declare a named-function, and that &quot;poolutes&quot; the enclosing scope</li>\n<li>Have to explicitly call the function by name to executes.</li>\n</ul>\n<p>A ideal way to fix these functions</p>\n<pre><code class=\"language-javascript\">var a = 2;\n(function() {\n    var a = 3;\n    console.log( a ); //3\n})();\n\nconsole.log( a ); //2</code></pre>\n<p>Instead fo treating the function as a standard declaration , treated it as funciton-expression(the pari <code>()</code> wrap the function).</p>\n<p>mostly seen in callbacks(function expressions), and the most difference to function declaration is no name bound as identifier.</p>\n<h4 id=\"anonymous-vs-named\">Anonymous vs. Named</h4>\n<ul>\n<li>Anonymous functions have tno useful name to display in stack traces, which can make debugging difficult.</li>\n<li>If the function needs to refer to itself then require the <strong>deprecated</strong> <code>arguments.callee</code>.</li>\n<li>A name is often helpful in providing more readable/understandable code.</li>\n</ul>\n<blockquote>\n<p>To avoid these draw-backs, <strong>Allways name your function expression.</strong></p>\n</blockquote>\n<h3 id=\"blocks-as-scopes\">Blocks as Scopes</h3>\n<h4 id=\"let\">let</h4>\n<p><code>let</code> alongside <code>var</code> as another way to declare variables, and attaches the variable declaration to the scope block(commonly a <code>{..}</code> pair) it&#39;s contained in.</p>\n<p><code>let</code> declarations will hot hoist to the entire scope(such as <code>var</code>), the declarations will only exist after the declaration statement.</p>\n<h4 id=\"garbage-collection\">Garbage Collection</h4>\n<p>Declaring explic blocks (<code>{}</code>) for variables to locally bind to is a powerful to do garbage colleciton.</p>\n<h2 id=\"hoisting\">Hoisting</h2>\n<pre><code class=\"language-javascript\">a = 2;\nvar a;\nconsole.log( a );  // 2\n\nconsole.lgo( b );  // undefined;\nvar b = 3;\n\nfoo();  // TypeError;\nvar foo = function() {\n    console.log(a);  \n    var a = 4;\n}</code></pre>\n<p><em>Engine</em> will compile code before it interprets it. and the <em>Compiler</em>&#39;s compilation phase was to find and associate all declarations with their appropriate scopes. And that results</p>\n<blockquote>\n<p>variables and function are processed first, before any part of code is executed.</p>\n</blockquote>\n<p>Actually the before code is handled like the follow</p>\n<pre><code class=\"language-javascript\">var a;\nvar b;\nvar foo;\n\na = 2;\nconsole.log(a);  // 2\n\nconsole.log(b);  // undefined;\nb = 3;\n\nfoo();  // TypeError\nfoo = function() {\n    var a;\n    console.log(a);\n    a = 4;\n}</code></pre>\n<blockquote>\n<ul>\n<li>Only declarations(variables and functions) are hoisted, but function expression are not.</li>\n<li>With duplicate declarations, Function are hoisted first and then variables(<strong>Functions First</strong>).</li>\n<li>For the same type of duplicate declarations, subsequent declarations <strong>do</strong> voerride previous one.</li>\n<li>Function Declarations that appear inside of normal blocks typically hoist to the enclosing scope.<br>Avoid declaring functions in blocks for it is to change in future version of JavaScript</li>\n</ul>\n</blockquote>\n<h2 id=\"scope-closure\">Scope Closure</h2>\n<p>Closure is all around in JavaScript, it is a result of writing code that relies on lexical scope.</p>\n<blockquote>\n<p><strong>Closure</strong> is when a function is able to remember and access its lexical scope even when that funciton is executing outside its lexical scope.</p>\n<p>When transport an inner function outside of its lexical scope, it will maintain a scope reference to where it was originally declared, and when execute the function, the closure will be exercised.</p>\n<p><strong>Closure</strong> 是在当方法的词法作用域在外部通过调用该方法获得的一个该函数与先定义的词法作用语的一个引用（技术上来说Closure可以发生在声明时期，但是并不能和词法作用域明显区分开）。</p>\n</blockquote>\n<pre><code class=\"language-javascript\">function foo() {\n    var a = 2;\n\n    function bar() {\n        console.log( a );\n    }\n\n    return bar()\n}\n\nvar baz = foo()\nbaz();\n</code></pre>\n<p>After <code>foo()</code> executed, normall we expect the entire of inner scope of <code>foo()</code> would go away for the Garbage Collection would free up memory when it&#39;s no longer in use.\nBut the closure won&#39;t let happen for <code>bar()</code> is still using it. <strong>as this <code>bar()</code> still has a reference to that scope, and this reference is called closure.</strong></p>\n<blockquote>\n<ul>\n<li>Function <code>bar()</code> close over the scope of <code>foo()</code>.</li>\n<li>Function <code>bar()</code> has a <em>closure</em> over of <code>foo()</code>.</li>\n<li>Closure let the function continue to access the lexical scope that defines in author-time.</li>\n</ul>\n</blockquote>\n<h3 id=\"iife-invoking-function-expressions-immediately-\">IIFE(Invoking Function Expressions Immediately)</h3>\n<p>IIFE is the most common tools used to create scope which can be closed over.  But some of it is not itself an example of closure(invoded right there in same scope, not the out side of the lexical scope.)</p>\n<pre><code class=\"language-javascript\">var a = 2;\n\n(function foo(){\n\n    var a = 3;\n    console.log( a ); // 3\n\n})();\n\nconsole.log( a ); // 2</code></pre>\n<h3 id=\"loops-closure-problem\">Loops + Closure Problem</h3>\n<pre><code class=\"language-javascript\">for (var i=1; i &lt;=5; i++) {\n    setTimeout(function timer(){\n        console.log(i);\n    }, i*1000);\n}</code></pre>\n<p>Each of the loop are defined separately in each iteration, but all are closed over the same shared global scope. And they all share a reference to the same <code>i</code>.</p>\n<p>For this problem to &quot;fix&quot; need more closure scope for each iteration.</p>\n<h4 id=\"with-iife\">with IIFE</h4>\n<p>As IIFE is a way to create scope by declaring a function and immediately executing it.</p>\n<pre><code class=\"language-javascript\">for (var i=1; i &lt;= 5; i++){\n    (function(){  // function(j) 代替var j＝i；\n        var j = i;  // 注意：IIFE的作用域为括号内，保存值的话要再IIFE内声明。\n        setTimeout(function timer(){\n            console.log(j);\n        }, j*1000)\n    })();\n}</code></pre>\n<p>Use IIFE inside each iteration which created a new scope for each iteration, and give the callback function to close over a new scope for each iteration, one had variable saved right value.</p>\n<h4 id=\"with-block-scoping-revisited\">with Block Scoping Revisited</h4>\n<p>Beside IIFE also could use <code>let</code> declaration, which <strong>hijacks a block and turns a block into a scope that can close over</strong>.</p>\n<pre><code class=\"language-javasript\">&#39;use strict&#39;  // perhaps need strict mode.\nfor(var i=1; i &lt;= 5; i++){  // 可以简写为 let i = 1; ...\n    let j = i;\n    setTimeout(function timer(){\n        console.log(j);\n    }, j*1000)\n}</code></pre>\n<h3 id=\"modules\">Modules</h3>\n<p><strong>Beside the power of closure patterns which do not to be about callbacks</strong>, is the module.</p>\n<pre><code class=\"language-javascript\">function CoolModule() {\n    var something = &quot;cool&quot;;\n    var another = [1, 2, 3];\n\n    function doSomething() {\n        console.log( something );\n    }\n\n    function doAnother() {\n        console.log( another.join( &quot; ! &quot; ) );\n    }\n\n    return {\n        doSomething: doSomething,\n        doAnother: doAnother\n    };\n}\n\nvar foo = CoolModule();\n\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1 ! 2 ! 3</code></pre>\n<p>The most common way of implementing  the module pattern is called &quot;Revealing Module&quot;.</p>\n<blockquote>\n<ol>\n<li>There must be an outer enclosing function, and it must be invoked at least onece(each time creates a new module instance),</li>\n<li>The enclosing funciton must return back at least one inner funciton, so that this inner function has closure over the private scope, and can access and /or modify the private state.</li>\n</ol>\n</blockquote>\n<h3 id=\"singleton-module\">Singleton Module</h3>\n<ol>\n<li>Turned module function into an IIFE</li>\n<li>Immediately invode it and assigned its return value directly to our single module instance identifier.</li>\n</ol>\n<h3 id=\"modern-modules\">Modern Modules</h3>\n<pre><code class=\"language-javascript\">var MyModules = (function Manager() {\n    var modules = {};\n\n    function define(name, deps, impl) {\n        for (var i=0; i&lt;deps.length; i++) {\n            deps[i] = modules[deps[i]];\n        }\n        modules[name] = impl.apply( impl, deps );\n    }\n\n    function get(name) {\n        return modules[name];\n    }\n\n    return {\n        define: define,\n        get: get\n    };\n})();</code></pre>\n<p>invoke with modern modules</p>\n<pre><code class=\"language-javascript\">MyModules.define( &quot;bar&quot;, [], function(){\n    function hello(who) {\n        return &quot;Let me introduce: &quot; + who;\n    }\n\n    return {\n        hello: hello\n    };\n} );\n\nMyModules.define( &quot;foo&quot;, [&quot;bar&quot;], function(bar){\n    var hungry = &quot;hippo&quot;;\n\n    function awesome() {\n        console.log( bar.hello( hungry ).toUpperCase() );\n    }\n\n    return {\n        awesome: awesome\n    };\n} );\n\nvar bar = MyModules.get( &quot;bar&quot; );\nvar foo = MyModules.get( &quot;foo&quot; );\n\nconsole.log(\n    bar.hello( &quot;hippo&quot; )\n); // Let me introduce: hippo\n\nfoo.awesome(); // LET ME INTRODUCE: HIPPO</code></pre>\n<h3 id=\"future-modules\">Future Modules</h3>\n<p>bar.js</p>\n<pre><code class=\"language-javascript\">function hello(who) {\n    return &quot;Let me introduce: &quot; + who;\n}\n\nexport hello;</code></pre>\n<p>foo.js</p>\n<pre><code class=\"language-javascript\">// import only `hello()` from the &quot;bar&quot; module\nimport hello from &quot;bar&quot;;\n\nvar hungry = &quot;hippo&quot;;\n\nfunction awesome() {\n    console.log(\n        hello( hungry ).toUpperCase()\n    );\n}\n\nexport awesome;</code></pre>\n<p>invode with future modules</p>\n<pre><code class=\"language-javascript\">// import the entire &quot;foo&quot; and &quot;bar&quot; modules\nmodule foo from &quot;foo&quot;;\nmodule bar from &quot;bar&quot;;\n\nconsole.log(\n    bar.hello( &quot;rhino&quot; )\n); // Let me introduce: rhino\n\nfoo.awesome(); // LET ME INTRODUCE: HIPPO</code></pre>\n<h3 id=\"dynamic-scope\">&quot;Dynamic Scope&quot;</h3>\n<p>JavaScript <strong>dose not, in fact, have dynamic scope</strong>. It has lexical scope. but <code>this</code> mechanism is kind of dynamic scope.</p>\n<blockquote>\n<p> Lexical scope is the set of rules about how the <em>Engine</em> can look-up variables and where to find them.\n JavaScript concerned with hwo and where function and scopes are devlared, not <strong>where they are called from</strong>. Another words, the scope chain is based on the nesting of scopes in code.</p>\n</blockquote>\n<pre><code class=\"language-javascript\">function foo() {\n    console.log( a ); // 2\n}\n\nfunction bar() {\n    var a = 3;\n    foo();\n}\n\nvar a = 2;\n\nbar();</code></pre>\n<p>Lexical scope is all about write-time, whereas dynamic scope(and <code>this</code>) are runtime.</p>\n<h3 id=\"polyfilling-block-scope\">Polyfilling Block Scope</h3>\n<pre><code class=\"language-javascript\">// write in ES6\n{\n    let a = 2;\n    console.log( a ); // 2\n}\n\nconsole.log( a ); // ReferenceError\n\n// write in pre-ES6\ntry{throw 2}catch(a){\n    console.log( a ); // 2\n}\n\nconsole.log( a ); // ReferenceError</code></pre>\n<hr>\n<h2 id=\"traditional-compiled-languages-compilation\">Traditional compiled-languages compilation</h2>\n<h3 id=\"1-tokenizing-lexing\">1. Tokenizing/Lexing</h3>\n<p>Breaking up a string of characters into meaningful(to language) chunks(<code>tokens</code>).</p>\n<h3 id=\"2-parsing\">2. Parsing</h3>\n<p>Taking a stream(array) of tokens and turning it into a tree of nested elements(<code>Abstract Syntax Tree</code>[AST]).</p>\n<h3 id=\"3-code-generation\">3. Code-Generation</h3>\n<p>Taking AST and turining it into executable code.</p>\n","$loki":2},{"_id":"Git-Best-Prictical","name":"Git Best Prictical","category":["Knowledge"],"createdAt":"2018-06-03T00:07:52.000Z","updateAt":"2018-06-03T00:07:52.000Z","size":6348,"meta":{"title":"Git管理最佳实践","meta":"Git分支管理来解决多功能多版并行开发中合并和管理代码的问题。","category":"Knowledge","tags":["git"],"cover":"/assets/images/post/git.jpg","color":"#FFFFFF","created":1528001956802,"version":0,"revision":0},"content":"<h1 id=\"git-\">Git 管理最佳实践</h1>\n<h5 id=\"-vincent-driessen-a-successful-git-branching-model\"><em>文章内容参考 Vincent Driessen 的 <a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">A Successful Git branching model</a></em></h5>\n<p>最佳实践解决的问题是在多人多任务多(发布)版本的开发过程中对代码管理的一种解决方案， 依照该方案可以多人同时并行开发，开发功能不需要依赖任何版本信息，并且保证线上代码和线下代码的一致性。</p>\n<h2 id=\"-\">分散管理和集中管理</h2>\n<p>集中管理：集中是核心代码分支集中在一个&quot;核心&quot;的repo(仓库)中，作为唯一一个控制代码核心管理的repo，按照git的命名方式通常叫做<code>origin</code>。</p>\n<blockquote>\n<p> 每个开发人员都可以针对这唯一的代码管理repo进行<code>pull</code>和<code>push</code>操作。</p>\n</blockquote>\n<p>分散管理： 分散是指针对不同的团队/开发人员，在功能完成提交到<code>origin</code>之前，使用自己单独的repo管理，多人的任务协同也可通过分散的分支进行同步。</p>\n<blockquote>\n<p> 每个开发人员都可以从其他非核心repo中<code>pull</code>代码变更。</p>\n</blockquote>\n<p><img src=\"/assets/images/post/git_repos.png\" alt=\"repos\">\n代码repo和交互关系示意图。</p>\n<h2 id=\"-\">主要的分支</h2>\n<p>核心repo保存并管理主要的分支，包括<code>master</code>和<code>develop</code>, 用来保存 生产环境 和 开发环境可用的 最新代码。</p>\n<h3 id=\"master-\">master 分支</h3>\n<p>master分支被用作为当前项目可上线的分支。</p>\n<blockquote>\n<p>提交到<code>master</code>分支的代码需要经过严格的检验，并可以当<code>master</code>分支有提交内容的时候自动同步更新到生产环境中。</p>\n</blockquote>\n<h3 id=\"develop\">develop</h3>\n<p>develop分支用作开发使用的最新分支，同时负责管理版本功能的先后顺序，并作为持续集成测试／每日构建的分支。</p>\n<blockquote>\n<p>当<code>develop</code>分支上的代码达到了稳定的状态才可以合并到<code>master</code>分之上。</p>\n</blockquote>\n<h2 id=\"-\">辅助分支</h2>\n<p>出了主要的<code>master</code>和<code>develop</code>分支外，还是用一些辅助分支来帮助并行开发，简化功能追踪，为生产环境作准备，快速修复线上问题。</p>\n<h3 id=\"-\">功能分支</h3>\n<p>推荐前缀: <strong><code>feature-*</code></strong>\n从 <code>develop</code> 分支切出 - 合并到 <code>develop</code> 分支\n功能分支用来开发新的功能，因为在开发功能时有可能不会预先知道功能要在哪个版本发布，所以只要功能在开发中相应的功能分支就会一直存在，知道被合并到<code>develop</code>分支中或弃用。</p>\n<p>切换到功能分支：</p>\n<pre><code class=\"language-shell\">$ git checkout -b newFeature develop\n＃Switched to a new branch &quot;newfeature&quot;</code></pre>\n<p>合并到<code>develop</code>分支：</p>\n<pre><code class=\"language-shell\">$ git checkout develop\nSwitched to branch &#39;develop&#39;\n$ git merge --no-ff newfeature\nUpdating ea1b82a..05e9557\n(Summary of changes)\n$ git branch -d newfeature\nDeleted branch myfeature (was 05e9557).\n$ git push origin develop</code></pre>\n<p>使用 --no-ff 取消 fast-forward, 可以保留分支存在的历史信息，并在合并的分支上生成一个新的节点, 不使用的话就会丢掉该分支存在信息。对比效果如图：</p>\n<p><img src=\"/assets/images/post/git_no_ff.png\" alt=\"pomodoro\">\n为了保证版本演进的清晰，我们希望采用这种做法。</p>\n<h3 id=\"-\">发布分支</h3>\n<p>推荐前缀: <strong><code>release-*</code></strong>\n从 <code>develop</code> 分支切出 - 合并到 <code>develop</code>/ <code>master</code> 分支\n发布分支用来完成一个新的发布版本的生成。 通常用来添加版本信息，和创建信息等。\n每个发布分支都会合并当前版本需要的所有功能分支。\n版本的相关信息都需要在创建发布分支时填写。\n除此之外一些bug修复可以提交到relase分支上。</p>\n<p>切换到发布分支：</p>\n<pre><code class=\"language-shell\">$ git checkout -b release-1.2 develop\nSwitched to a new branch &quot;release-1.2&quot;\n$ ./bump-version.sh 1.2\nFiles modified successfully, version bumped to 1.2.\n$ git commit -a -m &quot;Bumped version number to 1.2&quot;\n[release-1.2 74d9424] Bumped version number to 1.2\n1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>\n<p>发布发布分支:</p>\n<pre><code>$ git checkout master\nSwitched to branch &#39;master&#39;\n$ git merge --no-ff release-1.2\nMerge made by recursive.\n(Summary of changes)\n$ git tag -a 1.2</code></pre><blockquote>\n<p>可以使用 <code>-s</code> 或 <code>-u &lt;key&gt;</code> 来对tag进行加密。</p>\n</blockquote>\n<p>保留信息变更:</p>\n<pre><code>$ git checkout develop\nSwitched to branch &#39;develop&#39;\n$ git merge --no-ff release-1.2\nMerge made by recursive.\n(Summary of changes)</code></pre><p>删除发布分支</p>\n<pre><code>$ git branch -d release-1.2\nDeleted branch release-1.2 (was ff452fe).</code></pre><h3 id=\"-\">快速修复分支</h3>\n<p>推荐前缀: <strong><code>hotfix-*</code></strong>\n从 <code>master</code> 分支切出 - 合并到 <code>develop</code>/ <code>master</code> 分支\n快速修复分支更像一个未经计划的发布分支。用来紧急修复线上的bug。\n这样可以在开发和修复bug调用不同的人力来实现。</p>\n<p>创建修复分支：</p>\n<pre><code>$ git checkout -b hotfix-1.2.1 master\nSwitched to a new branch &quot;hotfix-1.2.1&quot;\n$ ./bump-version.sh 1.2.1\nFiles modified successfully, version bumped to 1.2.1.\n$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;\n[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1\n1 files changed, 1 insertions(+), 1 deletions(-)</code></pre><p>提交修改：</p>\n<pre><code>$ git commit -m &quot;Fixed severe production problem&quot;\n[hotfix-1.2.1 abbe5d6] Fixed severe production problem\n5 files changed, 32 insertions(+), 17 deletions(-)</code></pre><p>完成修复分支：</p>\n<pre><code>$ git checkout master\nSwitched to branch &#39;master&#39;\n$ git merge --no-ff hotfix-1.2.1\nMerge made by recursive.\n(Summary of changes)\n$ git tag -a 1.2.1</code></pre><p>同步修改内容：</p>\n<pre><code>$ git checkout develop\nSwitched to branch &#39;develop&#39;\n$ git merge --no-ff hotfix-1.2.1\nMerge made by recursive.\n(Summary of changes)</code></pre><blockquote>\n<p>如果有发布分支存在，那么修改内容应同步到发布分支上而不是开发分支上。</p>\n</blockquote>\n<p>删除同步分支：</p>\n<pre><code>$ git branch -d hotfix-1.2.1\nDeleted branch hotfix-1.2.1 (was abbe5d6).</code></pre><h2 id=\"git-\">Git 实践分支说明图</h2>\n<p><img src=\"/assets/images/post/git_map.png\" alt=\"pomodoro\">\n另附高清PDF文件，如果需要可以打印出来供团队使用。\n<a href=\"http://ole3021.me/files/Git-branching-model.pdf\">Git实践分支说明</a></p>\n<h2 id=\"-\">个人思考</h2>\n<p>对于feature分支个人觉得也可以同时放在核心的代码repo中与<code>develop</code>和<code>master</code>一起管理，这样多个小组或多人的协同开发就不需要同不同的repo进行交互，都和一个repo进行交互就可以了。</p>\n","$loki":3},{"_id":"Pomodoro","name":"Pomodoro","category":["Knowledge"],"createdAt":"2018-06-03T00:07:52.000Z","updateAt":"2018-06-03T00:07:52.000Z","size":14077,"meta":{"title":"番茄工作法","meta":"根据大脑的工作规律总结的单项行动的计划方法，通过使用固定的工作方法来提高工作效率、减少干扰、减少压力和不必要的担忧并在过程中自我改进从容的达成预期目标。","category":"Knowledge","tags":["agile"],"cover":"/assets/images/post/pomodoro.jpg","color":"#606060","created":1528001956802,"version":0,"revision":0},"content":"<h1 id=\"-\">番茄工作法</h1>\n<h2 id=\"-\">什么是番茄工作法</h2>\n<p>番茄工作法是根据大脑的工作规律总结的单项行动的计划方法，通过使用固定的工作方法来提高工作效率、减少干扰、减少压力和不必要的担忧并在过程中自我改进从容的达成预期目标的一种工作方法。</p>\n<h3 id=\"-\">番茄？</h3>\n<p>番茄工作法是通过把工作时间分割成细小的时间段，并在这段时间内专注的工作来提高效率，完成任务的一种方法，使用这种方法需要一个计时器来提醒工作时间的开始与结束，在 <strong>弗朗西斯科•西里洛（Francesco•Cirillo）</strong>最先创立的时候使用了一枚厨房的定时器，刚好这个定时器形状很像番茄（意大利语的 Pomodoro）。</p>\n<h3 id=\"-\">靠谱么？</h3>\n<p>番茄工作法与软件开发行业中的<a href=\"https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91\">敏捷开发(Scrum)</a>，<a href=\"https://zh.wikipedia.org/wiki/%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B\">极限编程(XP)</a>方法类似，这两种方法都是目前公认效率最高的软件开发管理方法，也被行业普遍采用。</p>\n<p>与番茄工作法相似的方法还有<code>PDCA循环</code>也被称作为<code>品质管理循环</code>,它也是一个解决问题的周期流程,通常分为四步：计划（Plan）－执行（Do）－评估（Check）－应用（Act）。而番茄工作法更好在于可以忽略流程管理，专注真正要做的事（敏捷思想）。</p>\n<p>除此之外，关于番茄工作法的著作、APP、文章也比比皆是，其中不乏很多专业大型的出版社，本文中的内容就是阅读 <strong>图灵社区（TURING）</strong> 的 <a href=\"http://www.ituring.com.cn/book/60\">番茄工作法图解：简单易行的时间管理方法</a> 一书归纳整理而来。\n<img src=\"/assets/images/post/pomodoro_clock.jpg\" alt=\"pomodoro\"></p>\n<h3 id=\"-\">对什么人有用？</h3>\n<p>使用番茄工作法，可以帮你解决下面这些困扰你工作的问题</p>\n<ul>\n<li>不能自觉、专注、清醒的思考</li>\n<li>面对复杂，不知从何下手</li>\n<li>事情太多，时间太少</li>\n<li>无聊琐事（扫尾工作），越拖越久</li>\n<li>小事忙了一天，大事一件没办</li>\n<li>最后期限，步步紧逼</li>\n<li>从休息中回到工作，心智调整不过来</li>\n<li>经常分神，被其他的事物吸引了注意力不能集中</li>\n<li>事情一错再错，不长记性</li>\n<li>一件事情拖的太久</li>\n<li>一件事情越做越复杂</li>\n<li>把时间浪费在适应复杂工作的方法上了</li>\n<li>只顾低头工作，没有及时总结提高效率</li>\n<li>没办法准确预估时间，不能合理安排其他工作时间</li>\n<li>现有的工作方法，纸上谈兵</li>\n<li>被工作牵着走，不能做自己想做的事情</li>\n<li>完美主义，成了拖延的借口</li>\n<li>前怕狼，后怕虎，害怕失败和批评</li>\n</ul>\n<h3 id=\"-\">对什么人没用？</h3>\n<ul>\n<li>一个已经达到完美的自律和高效率的人。</li>\n<li>一个完全不在乎规矩，方法，没有耐心读完 原著／这片文章 的人。</li>\n</ul>\n<h3 id=\"-\">番茄工作法对我的帮助</h3>\n<ul>\n<li>与时间化敌为友，不再因为一小时、一天、一周、一个月的时限充满焦虑。</li>\n<li>使我的活动单一，目标单一，成果惊人。</li>\n<li>TBC</li>\n</ul>\n<h2 id=\"-\">番茄工作法是如何优化大脑工作的</h2>\n<ul>\n<li>有规律有节奏的生活，最适合大脑。不规律更容易引起迷茫和焦虑。</li>\n<li>执行相同的动作和准备程序，可以使自我调整，进入最佳状态。</li>\n<li>通过反射建立特定行动的特定信号。</li>\n<li>左脑倾向于匹配，右脑倾向于直觉。</li>\n<li>大脑具有惊人的记忆和计算能力。</li>\n<li>大脑多巴胺产量不足，会增加肾上腺组，会显出多动症，不易集中注意力。</li>\n<li>大脑的记忆容量有限，不适合分心同时处理两个问题。</li>\n<li>可视化技术（思维导图）是理清联想脉络，服务长期记忆的最佳工具。</li>\n<li>将工作是为一连串的事件逐个击破，可以提高生产力。</li>\n<li>适度休息可以让大脑进行关联记忆，发现解决问题的新方法。</li>\n<li>重复的惯例的行动可以帮助在面对重重压力的时候更适应现场情况。</li>\n</ul>\n<p><code>心流</code> 一种精神状态，具有明确的目标、集中、专注、自我意识消失、时间感扭曲、直接和即时反馈、能力水平与面对挑战的平衡、个人控制感、工作本身的内在奖励、行为与认知的合一。</p>\n<p>心流是一种创造性的状态，但是心流状态下缺乏全局观念，创造力提高但是统筹能力下降，通过中断心流状态来纵览全局，部署行动，在下一个心流期间全身心投入到工作中。</p>\n<p>好的工作方法可以保持良好的工作状态，同时能准确预估工作量，应对变化和未知。</p>\n<ul>\n<li>工作状态不应该偏向巅峰，不偏向低谷，应该保持一个可持续的不步伐。</li>\n<li>加班是因为英雄主义和内疚，内疚是因为之前的不切实际的承诺。</li>\n<li>正确的决策是意识和直觉之间的平衡。</li>\n<li>努力限制变化带来的成本曲线，减缓其上升速度，避免成本暴增。</li>\n</ul>\n<h2 id=\"-\">工具</h2>\n<h4 id=\"-\">纸和笔（或相应软件）</h4>\n<ul>\n<li>记录<code>今日待办</code></li>\n<li>记录<code>活动清单</code></li>\n<li>记录<code>流程指标</code>，以便对流程做出修改。</li>\n</ul>\n<h4 id=\"-\">定时器（或相应软件）</h4>\n<p>用来计时并提醒每个<code>番茄钟</code>的开始与结束。</p>\n<h2 id=\"-\">番茄工作流程</h2>\n<h3 id=\"-\">计划</h3>\n<p>在每一天的开始，从<code>工作清单</code>（要做的工作中）中提取重要的工作添加到<code>今日待办</code>的表格中，表格中的内容就是今天的自我承诺。</p>\n<p>用5分钟的<code>番茄钟</code>记录要完成活动，不论重要与否，不必考虑重要程度和优先级，不必写出做法，还记录完成后的状态。如：</p>\n<blockquote>\n<p>Tips:</p>\n<ul>\n<li>言简意赅，推荐方法：用第一个词代表活动主题类型，第二个词代表实现是么。</li>\n<li>如果有最后期限限定的可以在最后加上截止日期时间。</li>\n</ul>\n</blockquote>\n<h3 id=\"-\">工作&amp;跟踪</h3>\n<h4 id=\"-\">每日计划</h4>\n<p>早晨的第一件事就是从“活动清单”中选择一些重要的并且今天要完成的活动加入到“今日待办”表格中。</p>\n<p>在计划阶段就设计出了全天的计划，但是如果要修改“今日待办”就要让大脑处于全局状态下 而不是 心流状态（刚刚经过休息的大脑可以更好的做出决策）。</p>\n<blockquote>\n<p>Tips:</p>\n<p>“活动清单”可以保持对全局的概览，避免陷入琐事当中</p>\n</blockquote>\n<h4 id=\"-\">实施计划</h4>\n<p>然后从“今日待办”表格中选择最重要的工作开始，并开启第一个“番茄钟”。通过自发的选择一些事情来做，并完成，可以奠定良好的时间管理基础。</p>\n<p>如果在“番茄钟”内提前完成了计划，则可以利用剩余的时间进行“过度学习”（回顾一下所做的事情，重复一下所学的东西），看看刚才的工作是否可以改进，或者有什么新的发现。</p>\n<p>遵循“现在就做”的原则，可以有效减少“不得不做”的工作。每天可以讲重要的活动排到第一位，并全力以赴去做，之后再重新评估它是否仍然最重要。</p>\n<blockquote>\n<p>Tips:</p>\n<ul>\n<li>通过选择“今日待办”来排除其他的干扰，让自己专注</li>\n<li>今天的事情要设法努力全部完成，如果没有完整则要调整</li>\n<li>通过“今日待办”这项策略，可以保证你在桌正确的事情，并全心全意的投入到工作当中。</li>\n<li>如果想真正精通某个领域，则必须进行过度学习——马尔科姆•格拉威尔</li>\n</ul>\n</blockquote>\n<h4 id=\"-\">休息</h4>\n<p>当一个“番茄钟”完成之后，要立即对该活动进行标记，然后休息一下。休息时间一般为5分钟，这期间不要进行任何智利活动，喝点水，想想晚上吃什么，或者运动一下。</p>\n<p>休息之后要决定是继续进行同一活动还是切换到另一个活动。</p>\n<p>在常规休息之外，可以将4个”番茄钟“作为一组，并在一组之后进行15～30分钟的阶段消遣。或者利用这段时间去进行一些小型活动。</p>\n<blockquote>\n<p>Tips:</p>\n<ul>\n<li>空闲时间为大脑提供燃料，哪怕仅剩下一点点的工作就可以完成任务而拖延休息时间。</li>\n<li>休息的时候不可以思考上一个或下一个“番茄钟”的工作内容。也不要打重要的电话，回复邮件。（不进行心智休闲调节，会影响大脑的功能，导致记忆能力，集中能力下降 ）</li>\n<li>切换活动应该是因为<code>重要程度</code>发生变化，或者上一项活动一经完成。</li>\n</ul>\n</blockquote>\n<h4 id=\"-\">跟踪计划</h4>\n<p>从活动的第一项开始，于此同时在每个在每个<code>番茄种</code>(一般为25分钟)内，收集一些过程指标，如：被中断次数。</p>\n<blockquote>\n<p>Tips:</p>\n<ul>\n<li>番茄工作法有一定的目标导向，量力而行，通过完成对自己的成活来获得精神奖杯。</li>\n<li>将心目中的&quot;必须的做完&quot;换成“从那里开始”，将“项目很大很重要”换成“我可以走出一小步”。</li>\n<li>事情堆积不做，不会减轻困难，只会雪上加霜。</li>\n</ul>\n</blockquote>\n<h3 id=\"-\">记录</h3>\n<p>结束了一天的工作后便进入记录阶段，首先将原始跟踪数据（你希望看到什么）复制到“记录”表格中。</p>\n<p>在一天工作结束时，将当天收集的数据归档，计入“记录”表格。如果跟踪了中断次数，中断次数也要记录下来。</p>\n<h3 id=\"-\">处理&amp;改善</h3>\n<p>从记录的原始数据中提取有用的信息。让抽象的数据变得言之有物。如：每个“番茄钟”内平均遇到的中断次数。</p>\n<p>将信息以某种可视化的方式组织起来，并从中找到改进流程的思路。以此获得最适合现实情况的工作习惯。坚持每天都这样回顾。</p>\n<p>改善是一种工作方法，是以改进为目标，对渐进变化的专注。如：是否需要让行动更小型化？是否有不必要的开销？</p>\n<blockquote>\n<p>Tips: 改进方法步骤</p>\n<ol>\n<li>以某种方式测量标准化的做法</li>\n<li>将测量指标与需求进行比较</li>\n<li>做出必要改变，再次测量</li>\n<li>将新的方法作为标准化方法</li>\n</ol>\n</blockquote>\n<h2 id=\"-\">中断（干扰）</h2>\n<p>在番茄钟时间内不应该切换活动，但是很可能会发生一些外部无法控制的中断，如：一个重要的电话，一些紧急必须去做的事情。</p>\n<p>美国一份研究显示，员工在办公室上班时，大约美3分钟就会被打断一次工作，人们电脑屏幕同时开的窗口数为8个。这种恶劣的现代生活方式被描述为“注意缺乏特征”（ADT），滚滚而来的信息洪流，将人们淹没在其中。</p>\n<h3 id=\"-\">保持可持续的步伐</h3>\n<p>全局观与心流是相对立的，没有办法纵览全局友同时专注细节。尽量减少“纵览全局”的活动，有利于保持专注，但不能不做。</p>\n<blockquote>\n<p>Tips:</p>\n<ol>\n<li>从放松状态开始，准备开始一天的工作</li>\n<li>用全局观，编排顺序选择重要的内容</li>\n<li>按动番茄时钟，开始专注工作，保持在心流状态</li>\n<li>完成番茄钟，进入放松状体，回到步骤1</li>\n</ol>\n</blockquote>\n<h3 id=\"-\">中断策略</h3>\n<p>番茄工作法不是闭关修炼，相反，它可以提升写作环境中的个人技能。\n常见的造成中断的原因有两种</p>\n<h4 id=\"-\">内部中断</h4>\n<p>直觉向心智发出信号，告诉自己要去做当前专注活动之外的事情。</p>\n<p>可记录中断应对策略：</p>\n<ol>\n<li>接受中断，并记录它。紧急地计划外的任务则应该添加到“今日待办”清单中，并特殊标记，同时在当前活动标记（<code>&#39;</code>）来记录这次中断。</li>\n<li>然后继续手头的工作，避免真的被打断。</li>\n</ol>\n<p>不可记录中断应对策略：\n番茄钟是不可分割的“原子”单位，如果被强行中断，则应该放弃这个番茄钟，也不能记录完成一个番茄钟。这时应当去解决紧急的事情，或休息一段时间后再重新开始。</p>\n<blockquote>\n<p>Tips:</p>\n<ul>\n<li>切勿在番茄钟期间切换到其他活动。“一旦番茄钟启动就必须走到响铃”。</li>\n<li>番茄钟记录不可以自我作弊，记录跟踪数据是为了更好的改进工作流程，而不是为了其他任何目的。</li>\n<li>当每天完成的番茄钟很少的时候可以尝试减短每个番茄钟的时间。（不同单位的番茄钟不可用来做对比）</li>\n</ul>\n</blockquote>\n<h4 id=\"-\">外部中断</h4>\n<p>有人询问或请求帮助，而且在等待你的答复。</p>\n<p>应对策略：</p>\n<ol>\n<li>告知：告知对方我在忙</li>\n<li>协商：请求推迟</li>\n<li>计划：记录活动名称，稍后为他计划番茄钟以及是否需要加入到“今日待办”</li>\n<li>答复：按照承诺回电或答复。可能需要放弃番茄钟。</li>\n</ol>\n<blockquote>\n<p>Tips:</p>\n<ul>\n<li>外部中断要做到明确可见（可视化），弄清中断的类型和数量。并在未来的计划中考虑进来这些因素。</li>\n</ul>\n</blockquote>\n<h2 id=\"-\">预估工作量</h2>\n<p>通过历史数据（番茄工作中的记录）对未来成果进行有效预估。</p>\n<p>明确每天对自己的承诺（今日待办），如果承诺无法完成则有可能是一下原因之一</p>\n<ul>\n<li>做预估的方法或能力有待改进</li>\n<li>工作开始后，出现新的情况，新的问题。</li>\n</ul>\n<p>对于预估的工作内容，如果超过7个“番茄钟”则应该将这个任务拆分成更小的任务，保持每个任务再番茄钟4个左右，对于一个“番茄钟”内可以完成的任务则预估为一个番茄钟，但用0来表示。</p>\n<p>在完成预估的前提下进行每日的自我承诺，可以增强做事的积极性。通过记录每天完成的番茄数来对自己的“番茄钟日流量”心中有数。</p>\n<p>如果实际完成任务所用的“番茄钟”超过预期，则应该记录并进行总结，找到预估失败的原因，也许将活动拆开，降低复杂度是个更好的选择。</p>\n<h2 id=\"-\">灵活自定义番茄工作法</h2>\n<p>在通过一段时间的使用番茄工作法后（建议两周以上，已确定到底哪里不合适自己），通过个人情况进行一些优化。如：</p>\n<ul>\n<li>经常工作被番茄钟的时间中断，则应该增加番茄时钟的长度。</li>\n</ul>\n<h2 id=\"-\">番茄工作法附录</h2>\n<p>工作辅助：\n<a href=\"http://www.flatpomodoro.com/\">Flat Tomato</a></p>\n","$loki":4},{"_id":"SS","name":"SS","category":["Knowledge"],"createdAt":"2018-06-03T00:07:52.000Z","updateAt":"2018-06-03T00:07:52.000Z","size":6673,"meta":{"title":"自建ShadowSocks服务备忘录","meta":"通过手动在虚拟云主机上搭建实现ShadowSocks服务，并使用Google BBR来加速访问速度。","category":"Knowledge","tags":["sss"],"cover":"/assets/images/post/sss.jpg","color":"#606060","created":1528001956802,"version":0,"revision":0},"content":"<h1 id=\"-shadowsocks-\">自建ShadowSocks服务备忘录</h1>\n<h2 id=\"-\">购买云主机</h2>\n<h3 id=\"vultr-\">Vultr主机</h3>\n<p>首先需要购买云主机(VPN服务器) ，推荐<a href=\"http://www.vultr.com/?ref=7092244\">Vultr日本</a>机房主机, 相比其他云主机主要网络流量更多(5美元1000G流量),另外主机性能也更强(官方数据).</p>\n<p><img src=\"/assets/images/post/vultr-performance.png\" alt=\"vultr-performance\"></p>\n<p>不过也可以使用其他主机。附上一张个主机性价比对比图(来自网络)。</p>\n<p><img src=\"/assets/images/post/plan-vs.png\" alt=\"plan-vs\"></p>\n<p>Vultr主机目前有15个机房(@Aug, 2017),  推荐其中亚洲区的日本机房，感兴趣也可以通过<a href=\"http://cloudharmony.com/speedtest-latency-for-vultr:compute\">Vultr主机延迟测试</a></p>\n<blockquote>\n<p>测试结果不包含新加坡机房，结果延迟和实际服务器的ip地址测试结果略微偏高</p>\n</blockquote>\n<p>来检查适合自己位置的机房。再上海的测试结果如下：</p>\n<p><img src=\"/assets/images/post/lagency-test.png\" alt=\"lagency-test\"></p>\n<blockquote>\n<p>可以在Vultr创建主机后用真实的主机ip地址测试，测试完删掉即可。</p>\n</blockquote>\n<p>我自己测试的结果是，再上海（电信）访问的话实测结果如下：</p>\n<ul>\n<li>🇯🇵日本机房平均:90毫秒</li>\n<li>🇸🇬新加坡平均:160毫秒</li>\n<li>🇺🇸美国Los Angeles机房平均:140毫秒</li>\n</ul>\n<p>其他机房测试地址(官方提供)</p>\n<table>\n<thead>\n<tr>\n<th>Location</th>\n<th>Domain</th>\n<th>Result(Shang Hai)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frankfurt, DE</td>\n<td>fra-de-ping.vultr.com</td>\n<td>330ms</td>\n</tr>\n<tr>\n<td>Paris, France</td>\n<td>par-fr-ping.vultr.com</td>\n<td>250ms</td>\n</tr>\n<tr>\n<td>Amsterdam, NL</td>\n<td>ams-nl-ping.vultr.com</td>\n<td>240ms</td>\n</tr>\n<tr>\n<td>London, UK</td>\n<td>lon-gb-ping.vultr.com</td>\n<td>190ms</td>\n</tr>\n<tr>\n<td>Singapore</td>\n<td>sgp-ping.vultr.com</td>\n<td>180ms</td>\n</tr>\n<tr>\n<td>New York (NJ)</td>\n<td>nj-us-ping.vultr.com</td>\n<td>330ms</td>\n</tr>\n<tr>\n<td>Tokyo, Japan</td>\n<td>hnd-jp-ping.vultr.com</td>\n<td>90ms</td>\n</tr>\n<tr>\n<td>Chicago, Illinois</td>\n<td>il-us-ping.vultr.com</td>\n<td>280ms</td>\n</tr>\n<tr>\n<td>Atlanta, Georgia</td>\n<td>ga-us-ping.vultr.com</td>\n<td>520ms</td>\n</tr>\n<tr>\n<td>Miami, Florida</td>\n<td>fl-us-ping.vultr.com</td>\n<td>350ms</td>\n</tr>\n<tr>\n<td>Seattle, Washington</td>\n<td>wa-us-ping.vultr.com</td>\n<td>330ms</td>\n</tr>\n<tr>\n<td>Dallas, Texas</td>\n<td>tx-us-ping.vultr.com</td>\n<td>200ms</td>\n</tr>\n<tr>\n<td>Silicon Valley, California</td>\n<td>sjo-ca-us-ping.vultr.com</td>\n<td>200ms</td>\n</tr>\n<tr>\n<td>Los Angeles, California</td>\n<td>lax-ca-us-ping.vultr.com</td>\n<td>140ms</td>\n</tr>\n<tr>\n<td>Sydney, Australia</td>\n<td>syd-au-ping.vultr.com</td>\n<td>220ms</td>\n</tr>\n</tbody></table>\n<p>推荐选择日本或者Los Angeles主机，日本主机更快，但是存在不小的丢包率，洛杉矶平均慢40ms，但是网络稳定无丢包，另外在使用VPN时不会根据位置默认显示日本网站。</p>\n<p><img src=\"/assets/images/post/ping-result.png\" alt=\"ping-result\"></p>\n<p>Vultr主机选择配置如下：</p>\n<ol>\n<li><p>Server Location (Tokyo)</p>\n</li>\n<li><p>Server Type(CentOS 7 x64)</p>\n</li>\n<li><p>Server Size($5/mo 1000GB Bandwidth)</p>\n</li>\n<li><p>Additional Features(不选)</p>\n</li>\n<li><p>Startup Script(不配置)</p>\n</li>\n<li><p>SSH Keys</p>\n<p>通过SSH方式可以更安全和方便的登陆(不需要密码)，关于SSH创建的方式参见<a href=\"https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/\">Github SSH Key教程</a>(这里的SSH创建会跳转到管理页面)，也可以不填写，创建成功后会可使用提供的默认管理员的账号密码SSH登陆。</p>\n</li>\n<li><p>Server Hostname &amp; Label(主机host填写后需要重装才能修改，默认是vultr.com,不过无关紧要)</p>\n</li>\n</ol>\n<h3 id=\"-\">安装服务</h3>\n<ol>\n<li><p>登陆主机</p>\n<pre><code> ssh root@服务器IP地址</code></pre><hr>\n<blockquote>\n<p> 密码在服务器详情中可以找到</p>\n</blockquote>\n</li>\n<li><p>检查CentOS内核并升级到最新以及安装BBR</p>\n<pre><code> wget -O- https://raw.githubusercontent.com/ole3021/scripts/master/centOS_BBR.sh | bash</code></pre></li>\n<li><p>重启并检查kernel升级到最新以及BBR安装成功</p>\n<pre><code> reboot\n uname -sr\n sysctl -a|grep congestion_control</code></pre></li>\n<li><p>安装pip和shadowsocks</p>\n<pre><code> yum install python-setuptools &amp;&amp; easy_install pip\n pip install shadowsocks</code></pre></li>\n<li><p>创建SS的配置文件 <code>/etc/shadowsocks.json</code></p>\n<pre><code> {\n     &quot;server&quot;: &quot;0.0.0.0&quot;,\n     &quot;server_port&quot;: 8388,\n     &quot;password&quot;: &quot;uzon57jd0v869t7w&quot;,\n     &quot;method&quot;: &quot;aes-256-cfb&quot;\n }</code></pre><hr>\n<blockquote>\n<ul>\n<li><code>method</code>为加密方法，可选<code>aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</code></li>\n<li><code>server_port</code>为服务监听端口</li>\n<li><code>password</code>为密码</li>\n</ul>\n</blockquote>\n</li>\n<li><p>配置SS启动脚本 <code>/etc/systemd/system/shadowsocks.service</code></p>\n<pre><code> [Unit]\n Description=Shadowsocks\n\n [Service]\n TimeoutStartSec=0\n ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json\n\n [Install]\n WantedBy=multi-user.target</code></pre></li>\n<li><p>启动SS服务</p>\n<pre><code> systemctl enable shadowsocks\n systemctl start shadowsocks</code></pre></li>\n<li><p>检查SS状态</p>\n<pre><code> systemctl status shadowsocks -l</code></pre><p> 服务启动成功后会显示如下内容</p>\n<pre><code> ● shadowsocks.service - Shadowsocks\n     Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)\n     Active: active (running) since Sun 2017-08-20 12:19:37 UTC; 11s ago\n Main PID: 10263 (ssserver)\n     CGroup: /system.slice/shadowsocks.service\n             └─10263 /usr/bin/python /usr/bin/ssserver -c /etc/shadowsocks.json\n\n Aug 20 12:19:37 vultr.guest systemd[1]: Started Shadowsocks.\n Aug 20 12:19:37 vultr.guest systemd[1]: Starting Shadowsocks...\n Aug 20 12:19:37 vultr.guest ssserver[10263]: INFO: loading config from /etc/shadowsocks.json\n Aug 20 12:19:37 vultr.guest ssserver[10263]: 2017-08-20 12:19:37 INFO     loading libcrypto from libcrypto.so.10\n Aug 20 12:19:37 vultr.guest ssserver[10263]: 2017-08-20 12:19:37 INFO     starting server at 0.0.0.0:3021</code></pre></li>\n<li><p>开放防火墙相应的端口</p>\n<pre><code> firewall-cmd --permanent --add-port=xxxx/tcp //xxxx 为设置的ss服务端口\n firewall-cmd --reload</code></pre><hr>\n<blockquote>\n<p>成功后会显示<code>success</code></p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"-ss-\">连接SS服务</h2>\n<p>连接SS推荐使用以下客户端进行连接</p>\n<ul>\n<li>Mac <a href=\"https://github.com/shadowsocks/ShadowsocksX-NG\">ShadowsocksX-NG</a></li>\n<li>Windows <a href=\"https://github.com/shadowsocks/shadowsocks-windows\">shadowsocks-windows</a></li>\n</ul>\n<h3 id=\"todo\">TODO</h3>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 整合部署安装代码为脚本方便实用</li>\n</ul>\n","$loki":5},{"_id":"Agile-Development","name":"Agile Development","category":["Software Engineering"],"createdAt":"2018-06-03T00:07:52.000Z","updateAt":"2018-06-03T00:07:52.000Z","size":10324,"meta":{"title":"敏捷开发知识总结","meta":"《敏开武士》阅读总结，包含敏捷开发的团队建设，项目开发，项目管理，以及如何交付敏捷项目的开发结果。","category":"Software_Enginerring","tags":["code","agile"],"cover":"/assets/images/post/agile-samurai.jpg","color":"#606060","created":1528001956802,"version":0,"revision":0},"content":"<h1 id=\"-\">敏捷开发</h1>\n<p>敏捷是一种软件交付的框架，态度和方法。并以精益、快速、实用为特征。</p>\n<ul>\n<li>成功且明晰的建立并快速启动敏捷项目</li>\n<li>明晰、公开和诚恳的方式去收集需求、作出估算和提出计划。</li>\n<li>雷厉风行的执行，不断的生产出高质量生产就绪代码。</li>\n</ul>\n<blockquote>\n<p>敏捷原则：通过今早和持续的交付有价值的软件来满足客户。</p>\n</blockquote>\n<ul>\n<li><p>将大问题拆分为多个小问题。</p>\n</li>\n<li><p>注意力集中在重要的事务上，心无杂念。 在一周到两周内从总故事列表中选取客户最重要的故事，然后转化为可运行测试的软件（迭代）。 &gt; 总故事列表：项目待做事项列表。包含用户故事，及团队的估算。</p>\n</li>\n<li><p>确保交付的东西可以使用。 要做就做的最好。</p>\n</li>\n</ul>\n<blockquote>\n<p>敏捷原则：可工作的软件时衡量项目成功的主要度量指标。</p>\n</blockquote>\n<ul>\n<li><p>寻求反馈。 做好准备接受以下三条简单原则：</p>\n<ul>\n<li>项目初期不可能收集到所有的需求。</li>\n<li>不管收集到什么需求，最总都会发生变化。</li>\n<li>总有任务会超时、超支。</li>\n</ul>\n</li>\n<li><p>必要时要改变过程。</p>\n</li>\n<li><p>勇于负责。</p>\n<ul>\n<li>控制质量。</li>\n<li>控制进度。</li>\n<li>设定期望值。</li>\n<li>吝惜开支。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-\">构建敏捷团队</h2>\n<p>敏捷项目中，预先设计好的角色并不存在，每个人都可以做任何工作。 敏捷团队中，分析、编码、设计、测试是一连串连续的活动，从来不会停下来。 敏捷特别强调整体段对和团队责任，团队中没有QA，每个人都是QA。</p>\n<ul>\n<li>集中办公：提高段对生产效率。</li>\n<li>专职客户：专职客户在演示版中现身、解答问题、给出反馈、为团队建设提供必要的知道和洞见（Scrum专职产品负责人）。</li>\n<li><p>自组织：让角色适应人，而不是人去适应角色。</p>\n<ul>\n<li>每个人自己创建计划、提出估算，全权负责。</li>\n<li>不担心所谓的头衔和角色，关注于不断交付可运行且测试过的软件。</li>\n<li>具有主动性，不唯命是从。</li>\n</ul>\n</li>\n<li><p>勇于承担和授权：如果团队责任感培养出现问题可以通过团队演示软件来提高团队责任感。 &gt; 敏捷原则：要善于激励项目人员。为他们提供所需的环境和支持，并相信他们能完成工作。</p>\n</li>\n<li><p>跨职能：跨职能团队要能够为客户提供全面的服务。且团队运转速度高效。不必再等什么许可。可以快速投入到工作中。</p>\n</li>\n</ul>\n<h3 id=\"-\">常见角色</h3>\n<p>客户：知道需要建立什么。<br> 敏捷团队：决定如何建立什么。<br> 敏捷开发不太关注谁扮演了什么，更关注角色是否被正确扮演。</p>\n<blockquote>\n<p>启动项目前思考： * 我擅长什么？ * 我如何执行？ * 我看中什么? * 希望我交付的结果是什么？</p>\n</blockquote>\n<ul>\n<li><p>敏捷客户：提供敏捷项目的所有需求，软件开发的对象。</p>\n<ul>\n<li>是某方面专家，致力引导团队、回答问题并提供反馈。</li>\n<li>设置优先级，决定何时建立那些东西。</li>\n<li>在产品临近最后期限时，决定什么东西不要开发。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>不是必须，精髓在于与客户沟通过的越直接，效果越好。</p>\n</blockquote>\n<ul>\n<li><p>敏捷分析师：开发一个特形式，需要他们介入进来，找出使其生效的所有具体细节。</p>\n<ul>\n<li>帮助客户编写故事。</li>\n<li>帮助创建实体模型，创建原型并分析帮助表达故事的重点。 @chap9</li>\n</ul>\n</li>\n<li><p>敏捷程序员：通过代码来实现客户的需求。完成功能。</p>\n<ul>\n<li>编写很多测试并经常将测试作为设计驱动手段。 @chap12,14</li>\n<li>持续的设计改进起软件构架。 @chap13</li>\n<li>确保代码库一直处于生产就绪状态，并能在街道通知后随时部署。 @chap15</li>\n</ul>\n</li>\n<li><p>敏捷测试者：了解软件效果，在项目早起就参与进来。</p>\n<ul>\n<li>与客户携手工作，帮助他们一测试的形式捕捉客户需求。</li>\n<li>协助开发者实现测试自动化，寻找漏洞，从可能的角度去破坏已用程序来完成大范围的探索性测试。</li>\n<li>大型测试，不忘记负载，扩展性测试，等。 @chap9</li>\n</ul>\n</li>\n<li><p>敏捷项目经理：不遗余力的清除团队成功道路上的一切障碍。</p>\n<ul>\n<li>不断计划，在计划，必要时在调整行程。 @chap8</li>\n<li>对大型项目设置内、外期望值：为管理方提供状态报告，维护与公司的关系，必要时保护团队不受外来伤害。</li>\n</ul>\n</li>\n<li><p>敏捷用户体验设计师：为客户创建可用的、称心如意的产品体验。</p>\n<ul>\n<li>专注于价值、快速反馈、并为客户尽力创建最棒的产品。</li>\n<li>UX设计者不惧以渐进和迭代的方式进行设计。他们会随着代码的辨析俄去构建并设计特性。</li>\n</ul>\n</li>\n<li><p>其他人：都应该是开发团队的一部分，与项目中其他人得到同样的待遇。</p>\n</li>\n</ul>\n<p>招聘注意：</p>\n<ul>\n<li>多面手：能惬意从事多方面工作的人。</li>\n<li>欣然接受模糊角色之人：寻找能够接受冲击，可以从容适应计划变更的人。</li>\n<li>能够放下自己架子的人：与其他人共同学习分享，成长。</li>\n</ul>\n<h2 id=\"-\">敏捷项目开端</h2>\n<p>确保所有人对问题的理解相同，或达成了共识。弄清楚项目背后的“为什么”。</p>\n<ul>\n<li>将项目的目标、愿景和背景传达给团队成员，使其在执行过程中做出明智的决策。</li>\n<li>向利益相关者提供信息以帮助他们决策项目是否应该继续。</li>\n</ul>\n<p>在任何新合约或销售的开始阶段，提出尖锐的问题来确保大家达成了共识。</p>\n<h3 id=\"-\">为什么会进行这个项目</h3>\n<p>为了达到项目真正意义上的成功，要先理解他们所做项目背后的“为什么”。这样可以帮助团队</p>\n<ul>\n<li>做出更好，更加明智的决策；</li>\n<li>更好的平衡各种矛盾，并作出更好的取舍。</li>\n<li>由他们被授权后可以独立的思考问题，所以能够做出更好、更具创造性的方案来。</li>\n</ul>\n<p>深入工作现场，了解真正的客户的需求，了解客户各种问题，变身为客户。 发现领导意图，对项目的目标、目的或使命的总结，在项目的关键时刻帮助做出正确的决策。</p>\n<h3 id=\"-\">做一个电梯演讲</h3>\n<p>可以帮助团队确认项目的真正目标和发展方向。</p>\n<ul>\n<li>带来清晰的思维。</li>\n<li>迫使团队从客户的角度去考虑问题。</li>\n<li>直达要点。</li>\n</ul>\n<blockquote>\n<p>对于［目标客户］来说<br>他们又这样的［需求或机会］<br>我们的［产品名称］<br>是一种［产品类别］的产品<br>我们产品的［主要的优势，令人信服的购买原因］<br>其不同于［主要的竞争产品］<br>在于我们的产品有如下［主要区别］</p>\n</blockquote>\n<h3 id=\"-\">设计产品包装</h3>\n<p>可以让团队专注于那些能够吸引客户的方面以及产品的潜在优势。对于团队的的交付都有巨大的益处。</p>\n<ol>\n<li>集思广益，列举产品的优势。</li>\n<li>创建一个广告词。</li>\n<li>设计产品包装。</li>\n</ol>\n<h3 id=\"-\">创建一个否定清单</h3>\n<p>确认我们项目应该做什么，也要清楚不应该做什么。</p>\n<blockquote>\n<p>范围内：需要注意的事务。<br>范围外：无需担心的事务。<br>未解决的：仍需作出决定的事情。</p>\n</blockquote>\n<h3 id=\"-\">结实邻居</h3>\n<p>在项目开始前划定出谁在你的项目社区内，将其纳入你的意识范围内，并开始与之建立联系。 在有求于人时，他们会更乐于帮助你。<br>召集团队，开动脑筋想想会与那些人有关，并与他们建立好的管理。准备咖啡、甜甜圈和诚意。</p>\n<h2 id=\"-\">梦想成真</h2>\n<h3 id=\"-\">出示解决方案</h3>\n<p>画出技术框架的高级蓝图，确保专注在同一件事情上。 同时可以大概了解到可能遇到的技术问题，并确保在建设项目时大家都能保持冷静。</p>\n<ul>\n<li>围绕工具和技术设置期望值。</li>\n<li>围绕项目边界和范围将假设形象化。</li>\n<li>可以沟通风险。</li>\n</ul>\n<p>与团队中的技术人员共同研究一下如何建设此项目。画出构架示意图，演练各种场景，尽量得出一个对项目规模和复杂度的认知。 挑选出适合团队的最适合的解决方案。</p>\n<h3 id=\"-\">那些夜不能寐的问题</h3>\n<p>与团队（包括客户）讨论哪些让我们交付面临的苦难的风险，有效降低相关问题带来的影响。<br>将风险摆放出来，去分成值得担心的和无需担心的。</p>\n<p>自我评价：</p>\n<ol>\n<li>在纸上写下所有可能搞砸的事情。</li>\n<li>认真考虑如何组织此类事情的发生。</li>\n<li>将纸撕掉</li>\n</ol>\n<h3 id=\"-\">估算项目规模</h3>\n<p>尽量计算出项目的完成时间，哪怕是不能准确的计算出完成时间，也要大致的给出一个猜测。</p>\n<blockquote>\n<p>兰迪.莫特：坚持开发周期不超过6个月。</p>\n</blockquote>\n<h3 id=\"-\">明确要舍弃什么。</h3>\n<p>根据项目的时间、范围、预算和质量等杠杆，确认重要的不重要的分别是什么。</p>\n<ol>\n<li>时间：时间是有限的，必须在规定的时间内尽最大的努力。</li>\n<li>预算：预算也是固定的、有限的，通常到后来就不会很宽裕。</li>\n<li>质量：不能用牺牲质量来换取时间。质量也应该是固定的。</li>\n<li>范围：唯一可以变动的东西，如果要做的东西太多，会减少工作量。</li>\n<li>除此之外还要列举出“无法确定的事情”，如好玩的电脑游戏。</li>\n</ol>\n<p>通过取舍滑块来评估具体项目的影响因素的重要性，并告知客户。</p>\n<h3 id=\"-\">对项目所需要的付出加以展示。</h3>\n<ul>\n<li><p>组建团队：讨论一下需要的角色，和对他们的期望，当有人加入到项目的时候对他们的期望。<br>特殊关注客户，以及在对多个利益相关方谁可以做最后的决策人。</p>\n<ul>\n<li>明确谁是真正的决策者：确保客户以一种声音去与团队对话。<br>通过放置滑轨版将问题提出来，避免许多困惑。</li>\n<li>估算花费：通过 人数x时长x综合股价 来进行快速估算。</li>\n</ul>\n</li>\n</ul>\n<p>完成以上就可以交付计划了<br>[] 正在建设什么以及为什么要这么做<br>[] 项目有何吸引人之处[] 需要清楚那些障碍<br>[] 谁是你的邻居<br>[] 解决方案是什么样子<br>[] 你所面临的主要挑战和风险<br>[] 项目究竟有多大<br>[] 准备在哪些方面灵活处置<br>[] 大概需要花费多少（时间和金钱）</p>\n","$loki":6}],"idIndex":[1,2,3,4,5,6],"binaryIndices":{},"constraints":null,"uniqueNames":[],"transforms":{},"objType":"blogs","dirty":false,"cachedIndex":null,"cachedBinaryIndex":null,"cachedData":null,"adaptiveBinaryIndices":true,"transactional":false,"cloneObjects":false,"cloneMethod":"parse-stringify","asyncListeners":false,"disableMeta":false,"disableChangesApi":true,"disableDeltaChangesApi":true,"autoupdate":false,"serializableIndices":true,"ttl":null,"maxId":6,"DynamicViews":[],"events":{"insert":[],"update":[],"pre-insert":[],"pre-update":[],"close":[],"flushbuffer":[],"error":[],"delete":[null],"warning":[null]},"changes":[]}],"databaseVersion":1.5,"engineVersion":1.5,"autosave":false,"autosaveInterval":5000,"autosaveHandle":null,"throttledSaves":true,"options":{"serializationMethod":"normal","destructureDelimiter":"$<\n"},"persistenceMethod":"fs","persistenceAdapter":null,"verbose":false,"events":{"init":[null],"loaded":[],"flushChanges":[],"close":[],"changes":[],"warning":[]},"ENV":"NODEJS"}